{% extends 'dialogue/base.html' %}
{% load static %}

{% block content %}
  <div class="boh-display">
    <div class="expression" id="boh-expression">[ â–€ Â¸ â–€]</div>
    <div class="dialogue-container">
      <span class="dialogue-prefix">â”€â”€â”¤</span>
      <span class="dialogue-text" id="dialogue-text"></span>
      <span class="dialogue-suffix">â”‚</span>
    </div>
  </div>

  <div class="static-text" id="static-display"></div>

  <!-- Ãrea para exibir diagramas ASCII -->
  <div class="list-model" id="ascii-display" style="display: none;"></div>

  <!-- Ãrea de input para respostas -->
  <div class="input-area" id="response-area" style="display: none;">
    <div class="input-options">
      <button class="control-btn" id="yes-btn" onclick="sendResponse('s')"><span class="text-green">S</span>im</button>
      <button class="control-btn" id="no-btn" onclick="sendResponse('n')"><span class="text-red">N</span>Ã£o</button>
    </div>
  </div>

  <!-- Ãrea para input de nome -->
  <div class="name-input" id="name-area" style="display: none;">
    <label for="name-input">Digite seu nome aqui:</label>
    <input type="text" id="name-input" maxlength="20" placeholder="Nome" />
    <button onclick="submitName()">Enviar</button>
  </div>

  <!-- Preload de Ã¡udios -->
  <div style="display: none;">
    {% for i in '12345678'|make_list %}
      <audio preload="auto" id="sound-{{ forloop.counter }}">
        <source src="{% static 'dialogue/sfx/p03voice_calm#' %}{{ forloop.counter }}.wav" type="audio/wav" />
      </audio>
    {% endfor %}
  </div>
{% endblock %}

{% block scripts %}
  <script>
    class BOHDialogue {
      constructor() {
        this.expressions = {
          idle: ['[ â–€ Â¸ â–€]', '[ â–€ Â° â–€]', '[ â–€ â–  â–€]', '[ â–€ â”€ â–€]', '[ â–€ ~ â–€]', '[ â–€ â–„ â–€]', '[ â–€ Â¬ â–€]', '[ â–€ Â· â–€]', '[ â–€ _ â–€]'],
          pokerface: ['[ â–€ â€— â–€]', '[ â–€ Â¯ â–€]', '[ â–€ Â¡ â–€]'],
          thinking: ['[ â”€ Â´ â”€]', '[ â”€ Â» â”€]'],
          'open mouth': ['[ â–€ ÃŸ â–€]', '[ â–€ â–ˆ â–€]'],
          annoyed: ['[ â–€ Ä± â–€]', '[ â–€ ^ â–€]'],
          'looking down': ['[ â–„ . â–„]', '[ â–„ _ â–„]', '[ â–„ â‚’ â–„]', '[ â–„ â€— â–„]']
        }
    
        // Controle de Ã¡udio melhorado
        this.soundEnabled = true
        this.sounds = []
        this.currentSound = null
        this.isTyping = false
        
        // Sistema de pausas
        this.isPaused = false
        this.waitingForSpacePress = false
        this.pauseResolver = null
        
        // Sistema de cache para posiÃ§Ã£o do diÃ¡logo
        this.currentDialogueStep = 0
        this.dialogueState = this.loadDialogueState()
        
        // Estados de resposta
        this.waitingForListRecognition = false
        this.waitingForUnderstanding = false
        this.waitingForContinue = false
        
        this.loadSounds()
        this.setupKeyboardControls()
        this.restoreOrInitDialogue()
      }

      // Sistema de cache para salvar/carregar estado
      saveDialogueState() {
        const state = {
          step: this.currentDialogueStep,
          timestamp: Date.now(),
          waitingForListRecognition: this.waitingForListRecognition,
          waitingForUnderstanding: this.waitingForUnderstanding,
          waitingForContinue: this.waitingForContinue
        }
        localStorage.setItem('boh_dialogue_state', JSON.stringify(state))
      }

      loadDialogueState() {
        const saved = localStorage.getItem('boh_dialogue_state')
        if (saved) {
          try {
            return JSON.parse(saved)
          } catch (e) {
            console.log('Erro ao carregar estado salvo:', e)
          }
        }
        return null
      }

      clearDialogueState() {
        localStorage.removeItem('boh_dialogue_state')
      }

      restoreOrInitDialogue() {
        if (this.dialogueState && this.dialogueState.step > 0) {
          // Mostrar opÃ§Ã£o de continuar
          this.showContinueOption()
        } else {
          this.initDialogue()
        }
      }

      showContinueOption() {
        const dialogueElement = document.getElementById('dialogue-text')
        dialogueElement.innerHTML = `
          <span class="text-yellow">Estado anterior encontrado!</span><br>
          Pressione <span class="text-green">ENTER</span> para continuar ou <span class="text-red">ESC</span> para recomeÃ§ar
        `
        
        const handleChoice = (event) => {
          if (event.key === 'Enter') {
            document.removeEventListener('keydown', handleChoice)
            this.resumeDialogue()
          } else if (event.key === 'Escape') {
            document.removeEventListener('keydown', handleChoice)
            this.clearDialogueState()
            this.initDialogue()
          }
        }
        
        document.addEventListener('keydown', handleChoice)
      }

      resumeDialogue() {
        // Implementar lÃ³gica para retomar do ponto salvo
        this.currentDialogueStep = this.dialogueState.step
        this.waitingForListRecognition = this.dialogueState.waitingForListRecognition
        this.waitingForUnderstanding = this.dialogueState.waitingForUnderstanding
        this.waitingForContinue = this.dialogueState.waitingForContinue
        
        // Por simplicidade, vou mostrar uma mensagem e continuar
        this.typeText('Continuando de onde paramos...', 'idle')
        setTimeout(() => this.continueFromStep(this.currentDialogueStep), 2000)
      }

      continueFromStep(step) {
        // Implementar navegaÃ§Ã£o baseada no step salvo
        if (step < 10) {
          this.initDialogue()
        } else if (step < 20) {
          this.continueListExplanation()
        } else {
          this.finalExplanation()
        }
      }
    
      loadSounds() {
        for (let i = 1; i <= 8; i++) {
          const audio = document.getElementById(`sound-${i}`)
          if (audio) {
            audio.volume = 0.7
            this.sounds.push(audio)
          }
        }        console.log(`Carregados ${this.sounds.length} efeitos sonoros`)
      }

      setupKeyboardControls() {
        document.addEventListener('keydown', (event) => {
          // Controle de pausa com barra de espaÃ§o
          if (event.code === 'Space') {
            event.preventDefault()
            if (this.isTyping || this.waitingForSpacePress) {
              this.togglePause()
            }
          }
          
          // Controles de resposta S/N (apenas quando nÃ£o pausado)
          if (!this.isPaused && !this.waitingForSpacePress) {
            const responseArea = document.getElementById('response-area')
            if (responseArea && responseArea.style.display !== 'none') {
              if (event.key.toLowerCase() === 's' || event.key.toLowerCase() === 'y') {
                this.sendResponse('s')
              } else if (event.key.toLowerCase() === 'n') {
                this.sendResponse('n')
              }
            }
          }        })
      }

      togglePause() {
        if (this.waitingForSpacePress) {
          // Se estava aguardando espaÃ§o, continuar
          this.waitingForSpacePress = false
          this.isPaused = false
          if (this.pauseResolver) {
            this.pauseResolver()
            this.pauseResolver = null
          }
          // Remover indicador de pausa
          const dialogueText = document.getElementById('dialogue-text').innerHTML
          if (dialogueText.includes('[PAUSADO]')) {
            document.getElementById('dialogue-text').innerHTML = dialogueText.replace(
              ' <span class="text-yellow">[PAUSADO - Pressione ESPAÃ‡O para continuar]</span>', ''
            )
          }
        } else if (this.isTyping && !this.isPaused) {
          // Se estava digitando, pausar
          this.isPaused = true
          this.waitingForSpacePress = true
          document.getElementById('dialogue-text').innerHTML += ' <span class="text-yellow">[PAUSADO - Pressione ESPAÃ‡O para continuar]</span>'
        }
      }      async waitForSpacePress() {
        if (!this.waitingForSpacePress) return Promise.resolve()
        
        return new Promise((resolve) => {
          this.pauseResolver = resolve
        })
      }
        })
      }
    
      playTypingSound() {
        if (!this.soundEnabled || this.sounds.length === 0) return
        
        // Parar qualquer som anterior
        if (this.currentSound) {
          this.currentSound.pause()
          this.currentSound.currentTime = 0
        }
        
        // Selecionar som aleatÃ³rio
        const sound = this.sounds[Math.floor(Math.random() * this.sounds.length)]
        
        // Configurar e tocar
        sound.currentTime = 0
        this.currentSound = sound
        
        const playPromise = sound.play()
        if (playPromise) {
          playPromise.catch(e => console.log('Erro ao tocar som:', e))
        }
      }

      stopCurrentSound() {
        if (this.currentSound) {
          this.currentSound.pause()
          this.currentSound.currentTime = 0
          this.currentSound = null
        }
      }
    
      async typeText(text, expression = 'idle', staticText = '', colorizeArrows = false, instantStatic = false) {
        const dialogueElement = document.getElementById('dialogue-text')
        const expressionElement = document.getElementById('boh-expression')
        const staticElement = document.getElementById('static-display')
    
        // Processar texto para cores e formataÃ§Ã£o
        text = this.processFormattedText(text)
        
        // Salvar estado
        this.currentDialogueStep++
        this.saveDialogueState()
    
        if (staticText) {
          const processedStatic = this.processFormattedText(staticText, colorizeArrows)
          
          if (instantStatic || text === '') {
            // AtualizaÃ§Ã£o instantÃ¢nea do static text
            staticElement.innerHTML = processedStatic
            staticElement.style.display = 'block'
            
            // Reproduzir apenas um som para mudanÃ§a instantÃ¢nea
            if (text === '' && staticText) {
              this.playTypingSound()
            }
            
            if (text === '') {
              // Se nÃ£o hÃ¡ texto para digitar, apenas aguardar o delay
              await this.sleep(500)
              return
            }
          } else {
            staticElement.innerHTML = processedStatic
            staticElement.style.display = 'block'
          }
        } else {
          staticElement.style.display = 'none'
        }
    
        if (text === '') return // Se nÃ£o hÃ¡ texto, sair
        
        dialogueElement.innerHTML = ''
        this.isTyping = true
    
        const expressionList = this.expressions[expression] || this.expressions['idle']

        for (let i = 0; i < text.length; i++) {
          // Verificar se estÃ¡ pausado
          if (this.waitingForSpacePress) {
            await this.waitForSpacePress()
          }
          
          const char = text[i]
          dialogueElement.innerHTML += char
    
          // Trocar expressÃ£o
          const exprIndex = Math.floor(i / (expressionList.length / 2)) % expressionList.length
          expressionElement.textContent = expressionList[exprIndex]
    
          // Reproduzir som para caracteres alfanumÃ©ricos (igual ao script original)
          if (/[a-zA-Z0-9]/.test(char)) {
            this.stopCurrentSound() // Parar som anterior
            this.playTypingSound()
          }
    
          // Pausa maior para pontuaÃ§Ã£o
          const delay = /[.!?]/.test(char) ? 200 : 30
          await this.sleep(delay)
        }
        
        this.isTyping = false
      }
    
      processFormattedText(text, colorizeArrows = false) {
        // Substituir cÃ³digos de formataÃ§Ã£o por classes CSS
        text = text.replace(/\033\[31m/g, '<span class="text-red">')
        text = text.replace(/\033\[32m/g, '<span class="text-green">')
        text = text.replace(/\033\[34m/g, '<span class="text-blue">')
        text = text.replace(/\033\[33m/g, '<span class="text-yellow">')
        text = text.replace(/\033\[35m/g, '<span class="text-purple">')
        text = text.replace(/\033\[36m/g, '<span class="text-cyan">')
        text = text.replace(/\033\[1m/g, '<span class="text-bold">')
        text = text.replace(/\033\[0m/g, '</span>')
    
        // Colorizar setas se necessÃ¡rio
        if (colorizeArrows) {
          text = text.replace(/[â€¹â€º]/g, '<span class="arrow-orange">$&</span>')
          text = text.replace(/[Â»Â«]/g, '<span class="arrow-blue">$&</span>')
        }
    
        return text
      }
    
      showASCII(content) {
        const asciiDisplay = document.getElementById('ascii-display')
        asciiDisplay.innerHTML = this.processFormattedText(content)
        asciiDisplay.style.display = 'block'
      }
    
      hideASCII() {
        document.getElementById('ascii-display').style.display = 'none'
      }
    
      showResponseArea() {
        document.getElementById('response-area').style.display = 'block'
      }
    
      hideResponseArea() {
        document.getElementById('response-area').style.display = 'none'
      }
    
      showNameInput() {
        document.getElementById('name-area').style.display = 'block'
      }
    
      hideNameInput() {
        document.getElementById('name-area').style.display = 'none'
      }
    
      sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms))
      }
    
      async initDialogue() {
        await this.typeText('Oi, tudo bem?')
        await this.sleep(1000)
    
        await this.typeText('Muito obrigado por executar o meu script')
        await this.sleep(1000)
    
        await this.typeText('Eu me chamo <span class="text-green text-bold">BOH!</span>', 'idle', '', false)
        await this.sleep(750)
    
        await this.typeText('He He', 'open mouth')
        await this.sleep(750)
    
        await this.typeText('Sabe...')
        await this.sleep(750)
    
        await this.typeText('Tipo,')
        await this.sleep(500)
    
        await this.typeText('', 'idle', 'Tipo, <span class="text-bold">ROH</span>', false, true)
        await this.sleep(500)
    
        await this.typeText('', 'idle', 'Tipo, <span class="text-bold">ROH-</span><span class="text-bold text-green">BOH</span>', false, true)
        await this.sleep(500)
    
        // SequÃªncia de risadas
        for (let i = 1; i <= 10; i++) {
          await this.typeText('', 'open mouth', 'HahA'.repeat(i), false, true)
          await this.sleep(50)
        }
    
        await this.sleep(1000)
        await this.typeText('Ai ai, sou meio comÃ©dia Ã s vezes, sabe?')
        await this.sleep(1000)
    
        await this.typeText('Mas, enfim,')
        await this.sleep(500)
    
        await this.typeText('E vocÃª, como se chama?')
        this.showNameInput()
      }
    
      async submitName() {
        const nameInput = document.getElementById('name-input')
        const name = nameInput.value.trim()
    
        if (name.length < 2) {
          await this.typeText('VocÃª sabe seu nome, nÃ©?')
          return
        }
    
        this.hideNameInput()
    
        await this.typeText('Olha olha olha, na verdade, eu nÃ£o tenho muito tempo...', 'pokerface')
        await this.sleep(1500)
    
        await this.typeText('Me desculpa! VocÃª parece ser uma pessoa muito legal, mas...')
        await this.sleep(1000)
    
        await this.typeText('A pessoa que me mandou aqui, queria falar sobre â†“ isso â†“', 'looking down')
    
        const listModel = 'None Ã— â€¹[H]Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹[T]Â» Ã— None'
        this.showASCII(listModel)
    
        await this.sleep(2000)
        await this.typeText('Reconhece?', 'idle', listModel)
        await this.sleep(1500)
    
        await this.typeText('Ih, verdade, cÃª nÃ£o consegue me responder, nÃ©?', 'idle', listModel)
        await this.typeText('Hmmm', 'thinking')
    
        for (let i = 1; i <= 3; i++) {
          await this.typeText('', 'thinking', 'Hmmm' + '.'.repeat(i), false, true)
          await this.sleep(500)
        }
    
        await this.typeText('JÃ¡ sei!', 'open mouth')
        await this.typeText('Aqui, toma')
    
        this.showResponseArea()
        await this.typeText('Agora sempre que eu te perguntar algo,')
        await this.typeText('VocÃª pode responder digitando')
        await this.typeText('A letra destacada que achar mais cabÃ­vel.')
        await this.typeText('Entendeu, nÃ©?')
      }
    
      async continueListExplanation() {
        await this.typeText('Enfim, voltando ao assunto...')
    
        const listModel = 'None Ã— â€¹[H]Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹[T]Â» Ã— None'
        this.showASCII(listModel)
        this.showResponseArea()
    
        await this.typeText('Reconhece isso aqui, nÃ©?', 'looking down', listModel)
    
        // Aguardar resposta do usuÃ¡rio sobre reconhecimento da lista
        this.waitingForListRecognition = true
      }
    
      async onListRecognized() {
        this.waitingForListRecognition = false
        this.hideResponseArea()
    
        await this.typeText('Pois Ã©, uma lista.')
        await this.sleep(1000)
    
        await this.typeText('Bom, como vocÃª jÃ¡ sabe... a lista Ã© uma estrutura de dados')
        await this.sleep(1000)
    
        await this.typeText('Mas tÃ´ aqui pra discutir um desafio especÃ­fico relacionado a ela...')
        await this.sleep(1000)
    
        await this.typeText('O desafio Ã© o seguinte:')
        await this.sleep(1000)
    
        await this.typeText('Que tal inverter uma lista?')
        await this.sleep(1000)
    
        await this.typeText('Ou melhor, qual seria a maneira mais eficiente de fazer isso?')
        await this.sleep(1000)
    
        await this.typeText('Bom, a gente pode fazer isso de vÃ¡rias maneiras...')
        await this.sleep(1000)
    
        await this.typeText('Mas, acho que a primeira coisa que vem Ã  cabeÃ§a Ã©...')
        await this.sleep(1000)
    
        // Mostrar lista com Head e Tail invertidos
        const swappedList = 'None Ã— â€¹<span class="text-red">[T]</span>Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹<span class="text-blue">[H]</span>Â» Ã— None'
        this.showASCII(swappedList)
        await this.typeText('Fazer isso, nÃ©?', 'idle', swappedList)
        await this.sleep(1500)
    
        await this.explainListInversion()
      }
    
      async explainListInversion() {
        const swappedList = 'None Ã— â€¹<span class="text-red">[T]</span>Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹<span class="text-blue">[H]</span>Â» Ã— None'
    
        await this.typeText('Trocando Head e Tail, o que era a "frente" da lista,', 'idle', swappedList)
        await this.typeText('Passa a ser o "final" dela, e vice-versa.', 'idle', swappedList)
        await this.typeText('Mas, pera aÃ­! Como isso acontece exatamente?', 'idle', swappedList)
        await this.typeText('Digamos que, a gente iguale <span class="text-red">Tail</span> a <span class="text-blue">Head</span>', 'idle', swappedList)
    
        // Lista com duas Heads
        const twoHeadsList = 'None Ã— â€¹<span class="text-blue">[H]</span>Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹<span class="text-blue">[H]</span>Â» Ã— None'
        this.showASCII(twoHeadsList)
        await this.typeText('Eita... agora temos duas Heads!', 'idle', twoHeadsList)
        await this.sleep(1500)
    
        await this.explainVariableAssignment()
      }
    
      async explainVariableAssignment() {
        const twoHeadsList = 'None Ã— â€¹<span class="text-blue">[H]</span>Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹<span class="text-blue">[H]</span>Â» Ã— None'
    
        await this.typeText('Isso porque <span class="text-red">Tail</span> = <span class="text-blue">Head</span> nÃ£o Ã© uma troca de valores,', 'idle', twoHeadsList)
        await this.typeText('SÃ³ estamos dizendo que <span class="text-red">Tail</span> agora recebe', 'idle', twoHeadsList)
        await this.typeText('O objeto contido dentro de <span class="text-blue">Head</span>.', 'idle', twoHeadsList)
        await this.typeText('Mas assim como abrir espaÃ§o numa estante pra guardar um livro,', 'idle', twoHeadsList)
        await this.sleep(1500)
        await this.typeText('NÃ£o significa que haverÃ¡ espaÃ§o para guardar novamente', 'idle', twoHeadsList)
        await this.typeText('O antigo livro que tiramos para guardar o livro novo...', 'idle', twoHeadsList)
        await this.typeText('O que significa que precisamos salvar', 'idle', twoHeadsList)
        await this.typeText('O antigo valor de Tail, antes de trocÃ¡-lo por Head.', 'idle', twoHeadsList)
        await this.sleep(1500)
    
        await this.introduceAUX()
      }
    
      async introduceAUX() {
        const auxAscii = `
           __
       _  |@@|
      / \\ \\--/ __
      ) O|----|  |   __
     / / \\ }{ /\\ )_ / _\\\\
     )/  /\\__/\\ \\__O (__
    |/  (--/\\--)    \\__/
    /   _)(  )(_
       \`---''---\`
    `
    
        this.showASCII(auxAscii)
        await this.typeText('Meu mano aqui se chama AUX,', 'idle', auxAscii)
        await this.sleep(1250)
        await this.typeText('Tudo bem contigo, patrÃ£o?', 'idle', auxAscii)
        await this.sleep(750)
        await this.typeText('Ele se ofereceu pra guardar o valor de Tail', 'idle', auxAscii)
        await this.typeText('Pra que a gente nÃ£o perca na hora de trocar...', 'idle', auxAscii)
    
        await this.continueWithAUX()
      }
    
      async continueWithAUX() {
        // AUX segurando o valor de Tail
        const auxHolding = `
            __
    (_|)   |@@|
     \\ \\__ \\--/ __ 
      \\o__|----|  |   __
          \\ }{ /\\ )_ / _\\\\
          /\\__/\\ \\__O (<span class="text-red">[T]</span>
          (--/\\--)    \\__/
          _)(  )(_
         \`---''---\`
    `
    
        this.showASCII(auxHolding)
    
        const listWithAux = auxHolding + '\n\nNone Ã— â€¹<span class="text-blue">[H]</span>Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹<span class="text-blue">[H]</span>Â» Ã— None'
    
        await this.typeText('Revisitando entÃ£o o estado da nossa lista', 'idle', listWithAux)
        await this.typeText('GraÃ§as ao AUX, que guardou o valor de Tail', 'idle', listWithAux)
        await this.typeText('Podemos facilmente colocar Tail onde o Head original estÃ¡', 'idle', listWithAux)
    
        // Lista corrigida
        const correctedList = auxHolding + '\n\nNone Ã— â€¹<span class="text-red">[T]</span>Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹<span class="text-blue">[H]</span>Â» Ã— None'
        this.showASCII(correctedList)
    
        await this.typeText('Obrigado AUX, vocÃª Ã© o cara! AtÃ© mais tarde!', 'idle', correctedList)
        await this.sleep(1000)
    
        await this.explainPointers()
      }
    
      async explainPointers() {
        const swappedList = 'None Ã— â€¹<span class="text-red">[T]</span>Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹<span class="text-blue">[H]</span>Â» Ã— None'
        this.showASCII(swappedList)
    
        await this.typeText('SÃ³ que, isso nÃ£o Ã© o suficiente, nÃ©?', 'idle', swappedList)
        await this.typeText('Por causa desses caras aqui: â€¹[]Â»', 'idle', swappedList)
        await this.typeText('Mais especificamente, â€¹ Â» , esses dois.', 'idle', swappedList)
        await this.typeText('No nosso caso, eles representam', 'idle', swappedList)
        await this.typeText('Os ponteiros que identificam', 'idle', swappedList)
        await this.typeText('Quais elementos precedem e sucedem', 'idle', swappedList)
        await this.typeText('O objeto observado, seja lÃ¡ qual vocÃª escolha.', 'idle', swappedList)
        await this.typeText('AtÃ© aÃ­ tudo bem, nÃ©?', 'idle', swappedList)
        await this.sleep(1500)
    
        this.showResponseArea()
        await this.typeText('Estamos na mesma pÃ¡gina, entÃ£o?', 'thinking', swappedList)
        this.waitingForUnderstanding = true
      }
    
      async sendResponse(response) {
        if (this.waitingForListRecognition) {
          this.hideResponseArea()
          if (response === 's') {
            await this.onListRecognized()
          } else {
            await this.typeText('NÃ£o?', 'open mouth')
            await this.typeText('Como assim pÃ´? Me esforcei tanto desenhar ela...', 'pokerface')
            await this.typeText('Ã‰ uma lista! A estrutura de dados!')
            await this.typeText('TÃ¡ vendo?')
            this.showResponseArea()
          }
          return
        }
    
        if (this.waitingForUnderstanding) {
          this.hideResponseArea()
          if (response === 's') {
            this.waitingForUnderstanding = false
            await this.continueArrowExplanation()
          } else {
            await this.explainListConcept()
          }
          return
        }
    
        if (this.waitingForContinue) {
          this.hideResponseArea()
          if (response === 's') {
            this.waitingForContinue = false
            await this.finalExplanation()
          } else {
            await this.typeText('Tudo bem entÃ£o, vamos fazer o seguinte...', 'idle')
            await this.typeText('VocÃª tÃ¡ precisando de um descanso,', 'idle')
            await this.typeText('Eu tÃ´ precisando de um descanso.', 'idle')
            await this.typeText('Vou dar uma pausa aqui, beleza?', 'idle')
            await this.typeText('Quando quiser continuar, Ã© sÃ³ teclar', 'idle')
    
            // Mostrar mensagem de pausa
            document.getElementById('dialogue-text').innerHTML = 'TÃ´ aqui pertinho, quando quiser continuar Ã© sÃ³ chamar!'
            this.showResponseArea()
            this.waitingForContinue = true
          }
          return
        }
    
        // Resposta original para o primeiro conjunto de perguntas
        this.hideResponseArea()
    
        if (response === 's') {
          await this.typeText('Show de bola!', 'open mouth')
        } else {
          await this.typeText('NÃ£o?', 'pokerface')
          await this.typeText('Pera, deixa eu repetir')
          this.showResponseArea()
          return
        }
    
        await this.continueListExplanation()
      }
    
      async explainListConcept() {
        await this.typeText('Bom, resumidamente, nesse conceito de lista,')
        await this.typeText('NÃ£o usamos um conceito de Ã­ndice,')
        await this.typeText('EntÃ£o a Ãºnica forma de saber "aonde"')
        await this.typeText('Cada objeto se encontra, Ã© atravÃ©s desses ponteiros,')
        await this.typeText('Pense que Ã© como uma corrente.')
        await this.typeText('Cada elo da corrente aponta para o prÃ³ximo,')
        await this.typeText('E cada um tambÃ©m sabe qual Ã© o elo anterior.')
    
        this.showResponseArea()
        await this.typeText('Agora fez mais sentido?')
        this.waitingForUnderstanding = true
      }
    
      async continueArrowExplanation() {
        const swappedList = 'None Ã— â€¹<span class="text-red">[T]</span>Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹<span class="text-blue">[H]</span>Â» Ã— None'
    
        await this.typeText('EntÃ£o, vamos lÃ¡!', 'open mouth', swappedList)
        await this.typeText('De modo geral, essas setinhas sÃ£o tÃ£o importantes', 'idle', swappedList)
        await this.typeText('Pra esse exercÃ­cio, que a gente vai precisar', 'idle', swappedList)
        await this.typeText('Deixar elas bem visÃ­veis, pra nÃ£o confundir.', 'idle', swappedList)
    
        await this.typeText('Que tal...', 'thinking', swappedList)
        await this.sleep(1500)
        await this.typeText('', 'thinking', 'Assim...', false, true)
        await this.sleep(500)
        await this.typeText('', 'thinking', 'Assim... â€¹â€ºÂ«Â»', true, true)
    
        await this.explainColoredArrows()
      }
    
      async explainColoredArrows() {
        const swappedList = 'None Ã— â€¹<span class="text-red">[T]</span>Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹<span class="text-blue">[H]</span>Â» Ã— None'
    
        await this.typeText('Melhorou, nÃ©?', 'idle', swappedList, true)
        await this.typeText('As setas simples, ou seja, â€¹ & â€º , destacadas em laranja,', 'idle', swappedList, true)
        await this.typeText('Representam a variÃ¡vel do nosso objeto que', 'idle', swappedList, true)
        await this.typeText('Nos mostra qual Ã© o elemento que o precede', 'idle', swappedList, true)
        await this.typeText('JÃ¡ as setas duplas, ou seja, Â» & Â« , destacadas em azul,', 'idle', swappedList, true)
        await this.typeText('Representam a variÃ¡vel do nosso objeto que', 'idle', swappedList, true)
        await this.typeText('Nos mostra qual Ã© o elemento que o sucede', 'idle', swappedList, true)
        await this.sleep(1500)
    
        await this.explainArrowInversion()
      }
    
      async explainArrowInversion() {
        const swappedList = 'None Ã— â€¹<span class="text-red">[T]</span>Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹<span class="text-blue">[H]</span>Â» Ã— None'
    
        await this.typeText('Seguindo essa lÃ³gica,', 'idle', swappedList, true)
        await this.typeText('Acho que deu pra perceber que a gente', 'idle', swappedList, true)
        await this.typeText('TambÃ©m vai precisar inverter essas setinhas', 'idle', swappedList, true)
        await this.typeText('Pra inverter a lista, certo?', 'idle', swappedList, true)
        await this.sleep(1500)
        await this.typeText('JÃ¡ que, simplesmente trocar Head e Tail', 'idle', swappedList, true)
        await this.typeText('NÃ£o trocou as setinhas, de cada elemento.', 'idle', swappedList, true)
        await this.typeText('EntÃ£o Ã© como se olhÃ¡ssemos para trÃ¡s,', 'idle', swappedList, true)
        await this.typeText('Mas continuÃ¡ssemos andando para frente.', 'idle', swappedList, true)
    
        this.showResponseArea()
        await this.typeText('AtÃ© aqui tudo bem? Posso continuar?', 'idle', swappedList, true)
        this.waitingForContinue = true
      }
    
      async finalExplanation() {
        const swappedList = 'None Ã— â€¹<span class="text-red">[T]</span>Â» â€¹[]Â» â€¹[]Â» ... â€¹[]Â» â€¹[]Â» â€¹<span class="text-blue">[H]</span>Â» Ã— None'
    
        await this.typeText('EntÃ£o, vamos lÃ¡!', 'open mouth', swappedList, true)
        await this.typeText('Se formos entÃ£o focar particularmente', 'idle', swappedList, true)
        await this.typeText('Na posiÃ§Ã£o que a Tail ocupa agora,', 'idle', swappedList, true)
    
        // ExplicaÃ§Ãµes finais sobre inversÃ£o de lista
        await this.typeText('Podemos ver que precisamos inverter', 'idle', swappedList, true)
        await this.typeText('NÃ£o apenas as referÃªncias Head e Tail,', 'idle', swappedList, true)
        await this.typeText('Mas tambÃ©m todas as conexÃµes internas!', 'idle', swappedList, true)
        await this.sleep(2000)
    
        await this.typeText('E Ã© assim que invertemos uma lista ligada!', 'open mouth', '', false)
        await this.sleep(1000)
        await this.typeText('Obrigado por me ouvir!', 'idle')
        await this.sleep(1000)
        await this.typeText('Tchau tchau!', 'open mouth')
    
        // Limpar tela e mostrar mensagem final
        setTimeout(() => {
          document.getElementById('dialogue-text').innerHTML = 'Fim do diÃ¡logo! ðŸŽ‰'
          document.getElementById('static-display').style.display = 'none'
          document.getElementById('ascii-display').style.display = 'none'
          this.clearDialogueState()
        }, 2000)
      }
    }
    
    // FunÃ§Ãµes globais para interaÃ§Ã£o
    function sendResponse(response) {
      if (window.bohDialogue) {
        window.bohDialogue.sendResponse(response)
      }
    }
    
    function submitName() {
      if (window.bohDialogue) {
        window.bohDialogue.submitName()
      }
    }
    
    // Inicializar quando a pÃ¡gina carregar
    document.addEventListener('DOMContentLoaded', function () {
      // Aguardar um clique para ativar Ã¡udio (requisito dos navegadores)
      document.addEventListener(
        'click',
        function initAudio() {
          window.bohDialogue = new BOHDialogue()
          document.removeEventListener('click', initAudio)
        },
        { once: true }
      )
    
      // Mostrar mensagem para clicar
      document.getElementById('dialogue-text').innerHTML = 'Clique em qualquer lugar para comeÃ§ar...'
    })
  </script>
{% endblock %}
